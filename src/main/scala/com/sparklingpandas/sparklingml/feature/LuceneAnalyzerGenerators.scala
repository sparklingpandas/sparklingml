package com.sparklingpandas.sparklingml.feature

import java.lang.reflect.Modifier
import java.io.PrintWriter

import scala.collection.JavaConverters._
import scala.collection.mutable.StringBuilder

import org.reflections.Reflections


import org.apache.spark.annotation.DeveloperApi

import org.apache.lucene.analysis.Analyzer
import org.apache.lucene.analysis.CharArraySet


/**
 * Code generator for LuceneAnalyzers (LuceneAnalyzers.scala). Run with
 * {{{
 *   build/sbt "runMain com.sparklingpandas.sparklingml.feature.LuceneAnalyzerGenerators"
 * }}}
 */
private[sparklingpandas] object LuceneAnalyzerGenerators {

  def main(args: Array[String]): Unit = {
    val (testCode, transformerCode) = generate()
    val testCodeFile = "src/test/scala/com/sparklingpandas/sparklingml/feature/LuceneAnalyzersTests.scala"
    val transformerCodeFile = "src/main/scala/com/sparklingpandas/sparklingml/feature/LuceneAnalyzers.scala"
    val header =
      """/*
        | * Licensed to the Apache Software Foundation (ASF) under one or more
        | * contributor license agreements.  See the NOTICE file distributed with
        | * this work for additional information regarding copyright ownership.
        | * The ASF licenses this file to You under the Apache License, Version 2.0
        | * (the "License"); you may not use this file except in compliance with
        | * the License.  You may obtain a copy of the License at
        | *
        | *    http://www.apache.org/licenses/LICENSE-2.0
        | *
        | * Unless required by applicable law or agreed to in writing, software
        | * distributed under the License is distributed on an "AS IS" BASIS,
        | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        | * See the License for the specific language governing permissions and
        | * limitations under the License.
        | */
        |
        |package com.sparklingpandas.sparklingml.feature
        |
        |import org.apache.spark.ml.param._
        |
        |import org.apache.lucene.analysis.Analyzer
        |
        |import com.sparklingpandas.sparklingml.param._
        |
        |// DO NOT MODIFY THIS FILE! It was auto generated by LuceneAnalyzerGenerators
        |
    """.stripMargin('|')
    List((testCode, testCodeFile), (transformerCode, transformerCodeFile)).foreach {
      case (code: String, file: String) =>
        val writer = new PrintWriter(file)
        writer.write(header)
        writer.write(code)
        writer.close()
    }
  }

  def generate(): (String, String) = {
    val reflections = new Reflections("org.apache.lucene");
    val generalAnalyzers = reflections.getSubTypesOf(classOf[org.apache.lucene.analysis.Analyzer]).asScala
    val concreteAnalyzers = generalAnalyzers.filter(cls => !Modifier.isAbstract(cls.getModifiers))
    // A bit of a hack but strip out the factories and such
    val relevantAnalyzers = concreteAnalyzers.filter(cls =>
      !(cls.toString.contains("$") || cls.toString.contains("Factory")))
    val generated = relevantAnalyzers.map{ cls =>
      generateForClass(cls)
    }
    val testCode = new StringBuilder()
    val transformerCode = new StringBuilder()
    generated.foreach{case (test, transform) =>
      testCode ++= test
      transformerCode ++= transform
    }
    (testCode.toString, transformerCode.toString)
  }

  def generateForClass(cls: Class[_]): (String, String) = {
    import scala.reflect.runtime.universe._
    val rm = scala.reflect.runtime.currentMirror

    val clsSymbol = rm.classSymbol(cls)
    val clsType = clsSymbol.toType
    val clsFullName = clsSymbol.fullName
    val clsShortName = clsSymbol.name.toString
    val constructors = clsType.members.collect{
      case m: MethodSymbol if m.isConstructor && m.isPublic => m }
    // Once we have the debug version constructorParametersLists should be useful
    val constructorParametersLists = constructors.map(_.paramLists).toList
    val constructorParametersSizes = constructorParametersLists.map(_(0).size)
    val javaReflectionConstructors = cls.getConstructors().toList
    val publicJavaReflectionConstructors = javaReflectionConstructors.filter(cls => Modifier.isPublic(cls.getModifiers()))
    val constructorParameterTypes = publicJavaReflectionConstructors.map(_.getParameterTypes())
    // We do this in Java as well since some of the scala reflection magic returns private
    // constructors even though its filtered for public. See CustomAnalyzer for an example.
    val javaConstructorParametersSizes = constructorParameterTypes.map(_.size)
    // Since this isn't built with -parameters by default :(
    // we'd need a local version built with it to auto generate
    // the code here with the right parameters.
    // https://docs.oracle.com/javase/tutorial/reflect/member/methodparameterreflection.html
    // For now we could dump the class names and go from their
    // or we could play a game of pin the field on the constructor.
    // local build sounds like the best plan, lets do that l8r

    // Special case for handling stopword analyzers
    val baseClasses = clsType.baseClasses
    // Normally we'd do a checks with <:< but the Lucene types have multiple
    // StopwordAnalyzerBase's that don't inherit from eachother.
    val isStopWordAnalyzer = baseClasses.exists(_.asClass.fullName.contains("Stopword"))

    val charsetConstructors = constructorParameterTypes.filter(! _.exists(_ != classOf[CharArraySet]))
    val charsetConstructorSizes = charsetConstructors.map(_.size)

    // If it is a stop word analyzer and has a constructor with two charsets then it takes
    // the stopwords as a parameter.
    if (isStopWordAnalyzer && charsetConstructorSizes.contains(1)) {
      // If there are more parameters
      val includeWarning = constructorParametersSizes.exists(_ > 1)
      val warning = if (includeWarning) {
        s"""
         | * There are additional parameters which can not yet be controlled through this API
         | * See https://github.com/sparklingpandas/sparklingml/issues/3
        """.stripMargin('|')
      } else {
        ""
      }
      val testCode =
        s"""
        |/**
        | * A super simple test
        | */
        | class ${clsShortName}LuceneTest extends LuceneStopwordTransformerTest {}
        """.stripMargin('|')
      val code =
        s"""
        |/**
        | * A basic Transformer based on ${clsFullName}. Supports configuring stopwords.${warning}
        | */
        |
        |class ${clsShortName}Lucene extends LuceneTransformer with HasStopwords with HasStopwordCase {
        |  def buildAnalyzer(): Analyzer = {
        |    // In the future we can use getDefaultStopWords here to allow people to control
        |    // the snowball stemmer distinctly from the stopwords.
        |    // but that is a TODO for later.
        |    if (isSet(stopwords)) {
        |      new ${clsFullName}(
        |        LuceneHelpers.wordstoCharArraySet($$(stopwords), !$$(stopwordCase)))
        |    } else {
        |      new ${clsFullName}()
        |    }
        |  }
        |}
        """.stripMargin('|')
      (testCode, code)
    } else if (constructorParametersSizes.contains(0) &&
      javaConstructorParametersSizes.contains(0)) {
      val testCode =
        s"""
        |/**
        | * A super simple test
        | */
        | class ${clsShortName}LuceneTest extends LuceneTransformerTest {}
        """.stripMargin('|')
      val code =
        s"""
        |/**
        | * A basic Transformer based on ${clsFullName} - does not support
        | * any configuration properties.
        | * See https://github.com/sparklingpandas/sparklingml/issues/3 & LuceneAnalyzerGenerators
        | * for details.
        | */
        |
        |class ${clsShortName}Lucene extends LuceneTransformer {
        |  def buildAnalyzer(): Analyzer = {
        |    new ${clsFullName}()
        |  }
        |}
        """.stripMargin('|')
      (testCode, code)
    } else {
      ("", s"""
        |/// There is no default zero arg constructor for ${clsFullName}
        """.stripMargin('|'))
    }
  }
}
